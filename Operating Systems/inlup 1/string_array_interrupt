.data

INPUT_BUFFER: .space 32
MSG:          .asciiz "\n\nString read from user: "      
  
        .text

main:
        # Enable interrupts ...

        # Other necessary initialization ...
    
 
program_0:
 
        # First program_0 executes. 

        # Prepare system call to read string. 

        # System call code 8 (read_string)
        li $v0, 8 

        # Address of buffer to store characters read from the keyboard. 
        la $a0, INPUT_BUFFER 

        # Size of buffer.
        li $a1, 32 

        # Initiate the read_string system call by causing a trap exception 
        # (exception code 13).
        teqi $zero, 0 

        # NOTE: program_0 should block until the string is ready.

        # NOTE: When the string is ready, program_0 should resume exception here. 

        # Print the string using the built in system call print_string. 

        li $v0, 4
        la $a0, MSG
        syscall 
 
        li $v0, 4
        la $a0, INPUT_BUFFER
        syscall

        # terminate normally.
 
        li $v0, 10 
        syscall 

 
program_1:
        
        # Code for program 1 goes here. 
         
        # Perform some work ...
        addi $t0, $t0, 1 

        # NOTE: You may try to make program_1 do something more interesting later.

        # For simplicity, make program_1 loop for ever. 
        j program_1
 

        .kdata

# What do you need to store here?

        
        .ktext 0x80000180

# Handle the trap exception and receiver ready interrupt.

# A read_string system call is initiated when a trap exception (exception code 13)
# occurs and $v0 == 8 (read_string system call code). 

# What information must be saved by the kernel when a read_string system call is initiated?

# How can the kernel detect if the read_string system call is complete?

# How can the kernel make program_1 execute until the read_string system call is complete?

# How can the kernel resume execution of program_0 when the read_string system call is
# complete? 

# After the read_string system call has been initiated, every time a receiver interrupt 
# occurs: 
#         - the kernel can store a character in the input buffer. 
#         - you may want to echo each character to the Run I/O display. 

# How can the kernel detect when the buffer is full?

# Should pressing on the enter key end the read_string system call even if the
# buffer is not full?